using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using PGx.Model.Enums;
using PGx.Model.Common;
namespace PGx.Model.Entities
{
    public partial class NamedAllele : IComparable<NamedAllele>
    {
        private Dictionary<String, String> m_popFreqMap;//[population,frequency], example:[Chinese,0.033]

        private SortedSet<VariantLocus> m_missingPositions;
        // generated by initialize()
        private SortedDictionary<VariantLocus, String> m_positionBaseMap;//[LocusObj,DelCTT],key is VariantLouc object,value is base state (A,G,C or T)
        private int m_score;//int type default value is 0
        private String m_permutations;//[position:allele]example:123456:delACT;789654;A;456987123:*?;88552369:[AG]
        public string LocusAlleleJson { get; set; }
        public string AlleleFrequency { get; set; }
        public NamedAllele(String id, String name, List<NamedAlleleDefinition> namedAlleleDefinition)
            : this(id, name, namedAlleleDefinition, new SortedSet<VariantLocus>())
        {

        }
        public NamedAllele(String id, String name, List<NamedAlleleDefinition> namedAlleleDefinition, SortedSet<VariantLocus> missingPositions)
        {

            M_Id = id;
            Name = name;
            this.NamedAlleleDefinition = namedAlleleDefinition;
            m_missingPositions = missingPositions;
        }
        //对PGx_KB中读取的NamedAllele定义(Haplotype)和从VCF中读取的sampleAllele组成的haplotype进行初始化：1.计算每个NamedAllele的分数；2.根据br38 position顺序进行排列（permutation）
        public void initialize()
        {
            m_positionBaseMap = new SortedDictionary<VariantLocus, String>();

            foreach (NamedAlleleDefinition namedAlleleDefinition in this.NamedAlleleDefinition)
            {
                if (namedAlleleDefinition == null)
                    continue;
                m_positionBaseMap.Add(namedAlleleDefinition.VariantLocus, namedAlleleDefinition.Allele);
                if (string.IsNullOrEmpty(namedAlleleDefinition.Allele) == false)
                {
                    m_score++;
                }
            }
            //if the allele is not defined, the allele is excluded.
            if (m_score == 0)
                return;
            calculatePermutations();
        }
        /**
         * Call this to initialize this object for use.
         * This variant of {@link #initialize} allows an arbitrary {@code score} to be set.
         *
         * @param score the score for this {@link NamedAllele}
         */
        public void initialize(int score)
        {

            //initialize(refVariants);

            //initialize();
            m_positionBaseMap = new SortedDictionary<VariantLocus, String>();

            foreach (NamedAlleleDefinition namedAlleleDefinition in this.NamedAlleleDefinition)
            {
                m_positionBaseMap.Add(namedAlleleDefinition.VariantLocus, namedAlleleDefinition.Allele);
            }

            calculatePermutations();

            m_score = score;
        }



        public String GetAllele(VariantLocus variantLocus)
        {

            if (m_positionBaseMap.ContainsKey(variantLocus))
            {
                return m_positionBaseMap[variantLocus];
            }
            else
                return null;
        }

        /**
         * Gets the score (the number of alleles that matched) for this allele if it is matched.
         * It is usually the same as the number of non-null alleles, but can be set to anything via
         * {@link #initialize(VariantLocus[], int)}.
         */
        public int getScore()
        {
            return m_score;
        }


        /**
         * Gets the positions that are missing from this NamedAllele.
         */
        public SortedSet<VariantLocus> getMissingPositions()
        {
            if (m_missingPositions == null)
            {
                // this is possible if marshalled via GSON
                m_missingPositions = new SortedSet<VariantLocus>();
            }
            return m_missingPositions;
        }


        /**
         * A mapping of population name to allele frequency
         */
        public Dictionary<String, String> PopFreqDic
        {
            get
            {
                if (this.PopulationFrequency == null || this.PopulationFrequency.Count() > 0)
                {
                    return m_popFreqMap;
                }
                foreach (var popfreq in this.PopulationFrequency)
                {
                    m_popFreqMap.Add(popfreq.Population, popfreq.Frequency.ToString());
                }
                return m_popFreqMap;
            }
            set { m_popFreqMap = value; }
        }





        public override String ToString()
        {
            return Name + " [" + M_Id + "]";
        }


        public int CompareTo(NamedAllele o)
        {

            int rez = new HaplotypeNameComparator().Compare(this.Name, o.Name);
            if (rez != 0)
            {
                return rez;
            }
            return String.Compare(M_Id, o.M_Id);
        }



        public override Boolean Equals(Object o)
        {
            if (this == o)
            {
                return true;
            }
            if (!(o is NamedAllele))
            {
                return false;
            }
            NamedAllele that = (NamedAllele)o;
            return Object.Equals(Name, that.Name) &&
                Object.Equals(M_Function, that.M_Function) &&
                Array.Equals(NamedAlleleDefinition, that.NamedAlleleDefinition);
        }


        public override int GetHashCode()
        {
            return this.HashCode(Name) + this.HashCode(M_Id) + this.HashCode(M_Function) + this.HashCode(NamedAlleleDefinition) + this.HashCode(PopulationFrequency);
        }
        public int HashCode(object a)
        {
            if (a == null)
            {
                return 0;
            }
            else
                return a.GetHashCode();

        }


        public String getPermutations()
        {
            if (m_permutations == null)
            { return string.Empty; }
            return m_permutations;
        }

        private void calculatePermutations()
        {

            List<NamedAlleleDefinition> sortedNamedAlleleDefinition = this.NamedAlleleDefinition.OrderBy(x => x.VariantLocus.Position).ToList();

            StringBuilder builder = new StringBuilder();
            foreach (var item in sortedNamedAlleleDefinition)
            {
                builder.Append(item.VariantLocus.getPosition())
                    .Append(":");
                String allele = item.Allele;
                //m_alleleMap.TryGetValue(item.VariantLocus, out allele);
                if (allele != null)
                {
                    if (item.VariantLocus.Type == VariantType.REPEAT.ToString())
                    {
                        //allele = allele
                        //    .replaceAll("\\(", "\\\\\\(")
                        //    .replaceAll("\\)", "\\\\\\)");
                        allele = Regex.Replace(allele, "\\(", "\\\\\\(");
                        allele = Regex.Replace(allele, "\\)", "\\\\\\)");
                    }
                    else if (item.VariantLocus.Type == VariantType.SNP.ToString() && allele.Length == 1)
                    {
                        allele = IupacExtention.getRegex(IupacExtention.lookup(allele));
                    }
                    builder.Append(allele);
                }
                else
                {
                    builder.Append(".*?");
                }
                builder.Append(";");
            }
            m_permutations = builder.ToString();
            m_permutations=m_permutations.Remove(m_permutations.LastIndexOf(";"));
        }
    }
}
